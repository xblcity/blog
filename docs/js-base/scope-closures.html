<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>作用域与闭包 | Blog</title>
    <meta name="generator" content="VuePress 1.8.2">
    <link rel="icon" href="/avatar.png">
    <meta name="description" content="小白龙的前端记录">
    
    <link rel="preload" href="/assets/css/0.styles.dabe8ef1.css" as="style"><link rel="preload" href="/assets/js/app.2bd044f4.js" as="script"><link rel="preload" href="/assets/js/2.f4862a58.js" as="script"><link rel="preload" href="/assets/js/41.7a986dc7.js" as="script"><link rel="prefetch" href="/assets/js/10.8fb1fe16.js"><link rel="prefetch" href="/assets/js/11.6da08593.js"><link rel="prefetch" href="/assets/js/12.05f390b2.js"><link rel="prefetch" href="/assets/js/13.a5cbbf23.js"><link rel="prefetch" href="/assets/js/14.c6e39d41.js"><link rel="prefetch" href="/assets/js/15.473bdbc5.js"><link rel="prefetch" href="/assets/js/16.aecd16b2.js"><link rel="prefetch" href="/assets/js/17.e1aac6b7.js"><link rel="prefetch" href="/assets/js/18.7d6b8101.js"><link rel="prefetch" href="/assets/js/19.a298ad69.js"><link rel="prefetch" href="/assets/js/20.033f6059.js"><link rel="prefetch" href="/assets/js/21.bf4e4770.js"><link rel="prefetch" href="/assets/js/22.40fbc736.js"><link rel="prefetch" href="/assets/js/23.17a76d0c.js"><link rel="prefetch" href="/assets/js/24.f12edf3b.js"><link rel="prefetch" href="/assets/js/25.2619f0e3.js"><link rel="prefetch" href="/assets/js/26.a1645028.js"><link rel="prefetch" href="/assets/js/27.28d12b0f.js"><link rel="prefetch" href="/assets/js/28.82b83bb5.js"><link rel="prefetch" href="/assets/js/29.8f8e378e.js"><link rel="prefetch" href="/assets/js/3.c55aeb90.js"><link rel="prefetch" href="/assets/js/30.33ce0b1c.js"><link rel="prefetch" href="/assets/js/31.c0c8d6b6.js"><link rel="prefetch" href="/assets/js/32.8283ef04.js"><link rel="prefetch" href="/assets/js/33.f8a2bec6.js"><link rel="prefetch" href="/assets/js/34.8d9523b2.js"><link rel="prefetch" href="/assets/js/35.3cf52220.js"><link rel="prefetch" href="/assets/js/36.45c80d85.js"><link rel="prefetch" href="/assets/js/37.6fd75f78.js"><link rel="prefetch" href="/assets/js/38.b51178c5.js"><link rel="prefetch" href="/assets/js/39.c091ace4.js"><link rel="prefetch" href="/assets/js/4.d8b5c8c5.js"><link rel="prefetch" href="/assets/js/40.8e775f72.js"><link rel="prefetch" href="/assets/js/42.00d1b7e2.js"><link rel="prefetch" href="/assets/js/43.726b8471.js"><link rel="prefetch" href="/assets/js/44.29f4df76.js"><link rel="prefetch" href="/assets/js/45.32f36537.js"><link rel="prefetch" href="/assets/js/46.127b41c9.js"><link rel="prefetch" href="/assets/js/47.2804bd02.js"><link rel="prefetch" href="/assets/js/48.c7555d89.js"><link rel="prefetch" href="/assets/js/49.2920847a.js"><link rel="prefetch" href="/assets/js/5.e2025a9c.js"><link rel="prefetch" href="/assets/js/50.8ec5d3af.js"><link rel="prefetch" href="/assets/js/51.55b8f4c5.js"><link rel="prefetch" href="/assets/js/52.d5b0b7a5.js"><link rel="prefetch" href="/assets/js/53.b76da15f.js"><link rel="prefetch" href="/assets/js/54.f36c6d8c.js"><link rel="prefetch" href="/assets/js/55.8ab690e5.js"><link rel="prefetch" href="/assets/js/56.b878d9e4.js"><link rel="prefetch" href="/assets/js/57.df558540.js"><link rel="prefetch" href="/assets/js/58.2be39380.js"><link rel="prefetch" href="/assets/js/59.3249a5b9.js"><link rel="prefetch" href="/assets/js/6.245201a0.js"><link rel="prefetch" href="/assets/js/60.4f62f4d3.js"><link rel="prefetch" href="/assets/js/61.bab3c64e.js"><link rel="prefetch" href="/assets/js/62.c5df6561.js"><link rel="prefetch" href="/assets/js/7.25e7c10d.js"><link rel="prefetch" href="/assets/js/8.620d2d61.js"><link rel="prefetch" href="/assets/js/9.102e8152.js">
    <link rel="stylesheet" href="/assets/css/0.styles.dabe8ef1.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><img src="/avatar.png" alt="Blog" class="logo"> <span class="site-name can-hide">Blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://reading.xblcity.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  读书笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/xblcity" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://blogc.xblcity.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客搭建
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://reading.xblcity.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  读书笔记
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://github.com/xblcity" target="_blank" rel="noopener noreferrer" class="nav-link external">
  Github
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div><div class="nav-item"><a href="https://blogc.xblcity.com" target="_blank" rel="noopener noreferrer" class="nav-link external">
  博客搭建
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/" aria-current="page" class="sidebar-link">介绍</a></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>JS基础</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js-base/summary.html" class="sidebar-link">前端知识体系</a></li><li><a href="/js-base/this.html" class="sidebar-link">理解this</a></li><li><a href="/js-base/call.html" class="sidebar-link">call, apply, bind手动实现</a></li><li><a href="/js-base/scope-closures.html" aria-current="page" class="active sidebar-link">作用域与闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js-base/scope-closures.html#_1-作用域" class="sidebar-link">1. 作用域</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js-base/scope-closures.html#_1-1-词法作用域-语法作用域" class="sidebar-link">1.1 词法作用域&amp;语法作用域</a></li><li class="sidebar-sub-header"><a href="/js-base/scope-closures.html#_1-2-js-作用域类型" class="sidebar-link">1.2 JS 作用域类型</a></li><li class="sidebar-sub-header"><a href="/js-base/scope-closures.html#_1-3-执行环境-作用域与作用域链" class="sidebar-link">1.3 执行环境，作用域与作用域链</a></li></ul></li><li class="sidebar-sub-header"><a href="/js-base/scope-closures.html#_2-闭包" class="sidebar-link">2. 闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/js-base/scope-closures.html#_2-1-函数执行机制与上下文环境" class="sidebar-link">2.1 函数执行机制与上下文环境</a></li><li class="sidebar-sub-header"><a href="/js-base/scope-closures.html#_2-2-理解闭包的例子" class="sidebar-link">2.2 理解闭包的例子</a></li></ul></li><li class="sidebar-sub-header"><a href="/js-base/scope-closures.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/js-base/copy.html" class="sidebar-link">赋值与深浅拷贝</a></li><li><a href="/js-base/inherit.html" class="sidebar-link">类与继承</a></li><li><a href="/js-base/object-methods.html" class="sidebar-link">Object 构造器及原型上的方法</a></li><li><a href="/js-base/eventloop.html" class="sidebar-link">JS 事件队列/循环(Event Loop)</a></li><li><a href="/js-base/es6.html" class="sidebar-link">ES6 知识点</a></li><li><a href="/js-base/ajax.html" class="sidebar-link">AJAX</a></li><li><a href="/js-base/func-program.html" class="sidebar-link">高阶函数</a></li><li><a href="/js-base/design-mode.html" class="sidebar-link">JS 设计模式</a></li><li><a href="/js-base/algorithm.html" class="sidebar-link">数据结构与算法</a></li><li><a href="/js-base/ts-basic.html" class="sidebar-link">Typescript 认知</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>JS应用</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/js-practice/throttle.html" class="sidebar-link">理解节流与防抖函数</a></li><li><a href="/js-practice/array.html" class="sidebar-link">数组的数据处理</a></li><li><a href="/js-practice/utils.html" class="sidebar-link">JS 常用工具函数/代码片段</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>框架及实践</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/react/lifecycle.html" class="sidebar-link">React 生命周期总结&amp;应用</a></li><li><a href="/react/react-hooks.html" class="sidebar-link">React-Hooks 总结&amp;实践</a></li><li><a href="/react/react-ts.html" class="sidebar-link">在 React 中使用 TS</a></li><li><a href="/react/redux.html" class="sidebar-link">Redux/React-Redux</a></li><li><a href="/react/redux-middleware.html" class="sidebar-link">Redux 中间件</a></li><li><a href="/react/find-house.html" class="sidebar-link">找房筛选条件表单封装</a></li><li><a href="/library/wx-web.html" class="sidebar-link">微信公众号网页登录与支付</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>前端综合知识</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-system/performance.html" class="sidebar-link">性能优化</a></li><li><a href="/fe-system/render.html" class="sidebar-link">从输入网址到页面渲染经历了什么</a></li><li><a href="/fe-system/http.html" class="sidebar-link">http 知识体系</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>工程化</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/fe-engineering/webpack-react.html" class="sidebar-link">使用 webpack 从零配置 React 开发环境及打包优化</a></li><li><a href="/fe-engineering/webpack.html" class="sidebar-link">webpack 配置及优化</a></li><li><a href="/fe-engineering/vs.html" class="sidebar-link">vscode 插件与配置</a></li><li><a href="/fe-engineering/git.html" class="sidebar-link">git 的使用</a></li><li><a href="/fe-engineering/git-account.html" class="sidebar-link">Git 多账号配置</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>后端</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/backend/little-points.html" class="sidebar-link">node 知识点</a></li><li><a href="/backend/blog.html" class="sidebar-link">博客的后端实现</a></li><li><a href="/backend/mysql.html" class="sidebar-link">mysql 使用</a></li><li><a href="/backend/server.html" class="sidebar-link">使用服务器</a></li><li><a href="/backend/nginx.html" class="sidebar-link">nginx 在 window 下的配置与使用</a></li><li><a href="/backend/ubuntu.html" class="sidebar-link">ubuntu服务器终端及图形界面连接</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="作用域与闭包"><a href="#作用域与闭包" class="header-anchor">#</a> 作用域与闭包</h1> <h2 id="_1-作用域"><a href="#_1-作用域" class="header-anchor">#</a> 1. 作用域</h2> <h3 id="_1-1-词法作用域-语法作用域"><a href="#_1-1-词法作用域-语法作用域" class="header-anchor">#</a> 1.1 词法作用域&amp;语法作用域</h3> <p>词法作用域 (静态作用域) 是指作用域是由书写代码时的位置决定的</p> <p>语法作用域 (动态作用域) 是由代码运行时的上下文决定的。</p> <p>闭包的实现就是基于词法作用域。但<code>JS</code>中的<code>this</code>有语法作用域的特征。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">1</span>

<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> value <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果按照 <code>js</code> 的词法作用域，输出的是 <code>1</code>，即 <code>foo</code> 函数的作用域链是在定义的时候已经被确定了，<code>foo</code> 内部没有 <code>value</code> 变量，则向上寻找全局作用域下的 <code>value</code> 变量。</p> <p>如果是语法作用域，输出的是 <code>2</code>，<code>foo</code> 内部没有 <code>value</code> 变量，向上寻找 <code>bar</code> 函数内部有没有 <code>value</code> 变量，找到了输出 <code>2</code>。</p> <h3 id="_1-2-js-作用域类型"><a href="#_1-2-js-作用域类型" class="header-anchor">#</a> 1.2 JS 作用域类型</h3> <p><code>JS</code> 作用域分为函数作用域，块作用域，全局作用域三种</p> <h4 id="_1-2-1-函数作用域"><a href="#_1-2-1-函数作用域" class="header-anchor">#</a> 1.2.1 函数作用域</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token comment">// 一些代码</span>
  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// ...</span>
  <span class="token punctuation">}</span>
  <span class="token comment">// 更多的代码</span>
  <span class="token keyword">var</span> c <span class="token operator">=</span> <span class="token number">3</span>
<span class="token punctuation">}</span>
</code></pre></div><p>全局作用域只有一个变量：<code>foo</code></p> <p><code>foo</code> 函数作用域内部：变量 <code>b, bar, a, c</code></p> <h4 id="_1-2-2-块作用域"><a href="#_1-2-2-块作用域" class="header-anchor">#</a> 1.2.2 块作用域</h4> <h5 id="try-catch"><a href="#try-catch" class="header-anchor">#</a> try...catch</h5> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">try</span> <span class="token punctuation">{</span>
  <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'发生错误'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span> <span class="token comment">// Error: 发生错误</span>
<span class="token punctuation">}</span>
</code></pre></div><p><code>catch</code> 分句会创建块作用域，在 <code>catch</code> 语句外拿不到 <code>err</code> 变量</p> <h5 id="let-const"><a href="#let-const" class="header-anchor">#</a> let, const</h5> <p><code>let</code> 为其声明的变量隐式的劫持了所在的作用域</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> foo <span class="token operator">=</span> <span class="token boolean">true</span>
<span class="token keyword">if</span> <span class="token punctuation">(</span>foo<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token number">2</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token comment">// 2</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>bar<span class="token punctuation">)</span> <span class="token comment">// ReferenceError: bar is not defined</span>
</code></pre></div><p><code>let</code> 声明的变量不会提升，但是声明依然会被收集。<code>let</code> 不会被初始化，<code>var</code> 会被初始化为 <code>undefined</code></p> <div class="language-js extra-class"><pre class="language-js"><code>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// ReferenceError: Cannot access 'a' before initialization</span>
<span class="token keyword">let</span> a
</code></pre></div><p>let 用于 for 循环</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">// Reference Error</span>
</code></pre></div><p><code>const</code> 与 <code>let</code> 表现行为一致，唯一不同的是 <code>const</code> 声明的变量无法被重新赋值，const 声明的引用类型不可以重新赋值(即改变指针)，但是可以对该类型增删改属性(如对象), 也可以增删改项(如数组)</p> <h4 id="_1-2-3-全局作用域"><a href="#_1-2-3-全局作用域" class="header-anchor">#</a> 1.2.3 全局作用域</h4> <p>在浏览器中全局作用域是 <code>window</code>，在全局作用域声明的变量可以在任何地方访问到</p> <h4 id="_1-2-4-变量提升与函数提升"><a href="#_1-2-4-变量提升与函数提升" class="header-anchor">#</a> 1.2.4 变量提升与函数提升</h4> <p>var 声明的变量存在变量提升，函数声明存在提升，并优先于变量提升，但是函数表达式并不会提升，比如：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// b函数执行了</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// undefined</span>
<span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// Uncaught ReferenceError: Cannot access 'c' before initialization</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span>
<span class="token keyword">function</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 函数声明</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b函数执行了'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> <span class="token function-variable function">c</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token comment">// 函数表达式</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'c函数执行了'</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="_1-3-执行环境-作用域与作用域链"><a href="#_1-3-执行环境-作用域与作用域链" class="header-anchor">#</a> 1.3 执行环境，作用域与作用域链</h3> <p>作用域链的存在与执行环境密不可分。</p> <blockquote><p>下面几段摘自JS高级程序设计</p></blockquote> <p>关键词：<strong>执行环境(execution context)</strong> <strong>变量对象(variable object)</strong> <strong>活动对象(activation object)</strong></p> <p><strong>执行环境(execution context)</strong>，有时简称为环境(context)。或者叫做<strong>上下文环境(context)</strong>。是 JS 中一个重要概念。执行环境定义了 <strong>变量</strong> 或 <strong>函数有权访问的其他数据(比如 this, arguments,callee 等)</strong> 每个执行环境都有一个与之关联的<strong>变量对象(variable object)</strong>，<strong>执行环境</strong>中定义的所有变量和函数都保存在这个<strong>变量对象</strong>中。虽然我们编写的代码无法访问这个的对象，但解析器在处理数据是会在后台使用它。</p> <p>全局执行环境是最外围的一个执行环境，根据 JS 实现所在的<strong>宿主环境</strong>不同，表示执行环境的对象也不一样，在 Web 浏览器中，全局执行环境被认为是 <code>window</code> 对象。因此所有的全局变量和函数都是作为 <code>window</code> 对象的属性和方法创建的。</p> <p>某个执行环境的所有代码执行完毕后，该环境被<strong>销毁</strong>，保存在其中的所有变量和函数定义也随之销毁(全局执行环境直到应用程序退出——比如关闭网页浏览器时才被销毁)。</p> <p>每个<strong>函数</strong>都有自己的<strong>执行环境</strong>，当执行流进入一个函数时，函数的环境就会被推入一个<strong>环境栈</strong>中，而在<strong>函数执行之后</strong>，<strong>栈将其环境弹出</strong>，把控制权返回给之前的<strong>执行环境</strong>。</p> <p>当代码在一个<strong>执行环境</strong>中执行时，会创建变量对象的一个<strong>作用域链</strong>。作用域链的用途，就是可以保证变量和函数可以被<strong>执行环境</strong>有效访问。作用域的前端，始终是当前执行的代码所在环境的变量对象，如果这个是函数，则将其<strong>活动对象(activation object)<strong>作为</strong>变量对象(variable object)</strong>。活动对象在最开始时值包含一个变量。即 arguments 对象(这个对象在全局环境中是不存在的)。<strong>作用域链</strong>的下一个变量对象来自<strong>外部环境</strong>，再下一个变量对象则来自下一个外部环境。这样，一直延续到全局执行环境<code>window</code>。全局执行环境放入变量对象始终都是作用域链的最后一个对象。</p> <p>标识符解析是沿着作用域链一级一级的搜索标识符的过程。搜索过程始终从作用域链的前端开始，然后逐级的向后回溯，直到找到标识符为止(如果找不到标识符，会报错)。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> color <span class="token operator">=</span> <span class="token string">'blue'</span>

<span class="token keyword">function</span> <span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>color <span class="token operator">===</span> <span class="token string">'blue'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    color <span class="token operator">=</span> <span class="token string">'red'</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    color <span class="token operator">=</span> <span class="token string">'blue'</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">changeColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>作用域链分析：</p> <p>在上面这个简单的例子中，<strong>函数</strong><code>changeColor</code> 的<strong>作用域链</strong>包含两个对象：它自己的变量对象(其中定义这个 <code>arguments</code> 对象),和全局环境的变量对象。可以在函数内部访问到变量 <code>color</code>，就是因为可以在全局环境<code>window</code>这个作用域俩找到它。</p> <h2 id="_2-闭包"><a href="#_2-闭包" class="header-anchor">#</a> 2. 闭包</h2> <p>闭包：<strong>函数</strong>在自己定义的词法作用域以外的地方执行，但是可以记住并访问到所在的<strong>词法作用域</strong>。<strong>闭包是针对于函数而言</strong></p> <p>上述概念比较抽象，可以理解为执行完的函数其<strong>执行环境</strong>应该被销毁了，但是由于<strong>其他函数引用了这个函数的内部变量</strong>，导致其执行环境还存在，这就形成了闭包。</p> <p>了解闭包，需要知道<strong>作用域链</strong>和<strong>函数执行机制</strong>(即变量查找过程和函数执行环境的存在)</p> <h3 id="_2-1-函数执行机制与上下文环境"><a href="#_2-1-函数执行机制与上下文环境" class="header-anchor">#</a> 2.1 函数执行机制与上下文环境</h3> <p>由于 js 函数执行的原理，当函数被调用时，会被推送到一个执行栈中，形成自己的执行环境(执行环境中包含定义的变量与函数)，函数执行完则出栈，因而函数的执行环境也被销毁</p> <p>那么如何获取执行完毕的函数内部的变量呢，即如何让函数执行的执行环境不被销毁呢，这就要通过闭包了，<strong>闭包使得在执行的函数与应当被销毁的父函数产生了关联，使得作用域一直存在</strong>，这也是<strong>闭包最常见的一种用法</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> count <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    count<span class="token operator">++</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token comment">// 输出2</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> addCount <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 赋值，addCount指向引用类型bar()</span>
<span class="token function">addCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上述例子，<code>bar</code> 引用了父级函数 <code>foo</code> 里面的 <code>count</code> 变量，所以在函数 <code>foo</code> 执行过后,<code>count</code> 变量没有被立即销毁，我们通过 <code>addCount</code> 函数又可以获取到 <code>foo</code> 内部变量 <code>count</code> 的值，即 <code>bar</code> 函数被定义的地方。</p> <p>闭包阻止了 <code>foo</code> 函数的销毁，但要注意的是，大量的使用闭包会造成 <code>js</code> 内存无法及时得到释放。</p> <h3 id="_2-2-理解闭包的例子"><a href="#_2-2-理解闭包的例子" class="header-anchor">#</a> 2.2 理解闭包的例子</h3> <h4 id="_2-2-1-常见的闭包例子"><a href="#_2-2-1-常见的闭包例子" class="header-anchor">#</a> 2.2.1 常见的闭包例子</h4> <p>最简单的一种</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> bar
<span class="token punctuation">}</span>
<span class="token keyword">const</span> baz <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 2</span>
</code></pre></div><p>当函数可以记住并访问所在的词法作用域，即使函数名是在当前词法作用域之外执行，这就产生了闭包。</p> <p>在上例中：<code>foo</code> 函数执行, <code>baz</code> 函数即等同于 <code>bar</code> 函数，<code>baz</code> 函数执行的时候，要打印 <code>2</code>，由于 <code>baz</code> 函数本身没有变量 <code>a</code>, 向父级作用域查找，找到了 <code>a</code> 是 <code>2</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">2</span>
  <span class="token keyword">function</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token comment">// 2</span>
  <span class="token punctuation">}</span>
  <span class="token function">bar</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">3</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// 这里的fn实际是baz函数</span>
<span class="token punctuation">}</span>
<span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>上例中，<code>baz</code> 函数访问到被定义时的作用域的变量 <code>a=2</code>, 而不是执行时的 <code>a=3</code>。也间接证明了 <code>JS</code> 遵循词法作用域(静态作用域)的规则。</p> <h4 id="_2-2-2-定时器与循环"><a href="#_2-2-2-定时器与循环" class="header-anchor">#</a> 2.2.2 定时器与循环</h4> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token parameter">message</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">wait</span><span class="token punctuation">(</span><span class="token string">'Hello, closure!'</span><span class="token punctuation">)</span>
</code></pre></div><p><code>wait</code> 函数在执行完毕后，局部变量 <code>message</code> 本应被立即销毁，但是由于 <code>timer</code> 函数引用了 <code>message</code> 变量，使得 <code>wait</code> 函数的执行环境依然存在。使得 <code>timer</code> 能够访问到 <code>message</code> 变量，也就形成了闭包。</p> <p>深入到引擎的内部原理中，内置的工具函数 <code>setTimeout(..)</code> 持有对一个参数的引用，这个参数也许叫作 <code>fn</code> 或者 <code>func</code>，或者其他类似的名字。引擎会调用这个函数，在例子中就是内部的 <code>timer</code> 函数，而词法作用域在这个过程中保持完整。这就是闭包。也就是说，只要使用了定时器函数，必然会形成闭包。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// 输出5次6</span>
</code></pre></div><p>这段代码在运行时会以每秒一次的频率输出五次 6。</p> <p>为什么呢，又要涉及到 <code>js</code> 的执行机制了，由于 <code>js</code> 是单线程引擎，所以 <code>js</code> 会首先执行同步代码。再执行异步代码。也即是说延迟函数的回调会在同步<code>for</code>循环结束时才执行。关于 <code>JS</code> 异步知识可以参考<a href="https://blog.xblcity.com/js-base/eventloop.html" target="_blank" rel="noopener noreferrer">事件循环<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <p>上述例子中，<code>js</code> 会首先执行 <code>for</code> 循环，执行完毕后，<code>i</code> 已经变成了 <code>6</code>，这时候在执行定时器，定时器现在作用域链查找到的 <code>i</code> 值为 <code>6</code>。</p> <p>是尽管循环中的五个函数是在各个迭代中分别定义的，但是它们都被封闭在一个共享的全局作用域中，因此实际上只有一个 <code>i</code>。只不过 <code>i</code> 一直被重新赋值而已</p> <p>为了能够打印出 <code>1~6</code>。我们需要更多的闭包作用域，特别是在循环的过程中每个迭代都需要一个闭包作用域。</p> <p>如何打印出 <code>1~6</code> 呢，这里我们会想到给<code>setTimeout</code>内部储存一个 <code>i</code> 变量，每次执行<code>setTimeout</code>都访问自己独一无二的变量。再 <code>ES6</code> 之前，我们这样做：<br>
使用 <code>IIFE(Immediately Invoked Function Expression)</code>,即立即调用函数表达式。利用<strong>函数作用域</strong>保存每一次循环产生的变量</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token punctuation">;</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">j</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token comment">// 1,2,3,4,5,6 立即打印</span>
    <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token comment">//1,2,3,4,5,6 隔一秒打印一次</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>这里，我们使用了一个立即执行函数，形成闭包作用域，每次 <code>for</code> 循环时，立即执行函数被执行，<code>i</code> 变量传入立即执行函数内部，每个立即执行函数都会保存输入自己作用域内部的 <code>i</code> 变量，所以当定时器执行时，输出的就是各自匿名函数内部的 <code>j</code> 变量，即<code>1,2,3,4,5,6</code>了。</p> <p>也就是上述例子存在了<strong>两个闭包</strong>，一个是 <code>IIFE</code>，一个是定时器函数。</p> <p>在 <code>ES6</code> 之后，我们就不用这么麻烦了，</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token function">timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token comment">//1,2,3,4,5,6</span>
  <span class="token punctuation">}</span><span class="token punctuation">,</span> i <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们使用了 <code>ES6</code> 新增的声明变量的方式 <code>let</code>, <code>let</code> 声明的是局部变量，因为 <code>ES6</code> 新增了块作用域的概念，所以 <code>for (...) {...}</code> 大括号里面就是一个单独的作用域，<strong>即闭包作用域</strong>，<code>for</code> 循环的每次执行,都会把 <code>i</code> 的值传入块作用域内，所以 <code>for</code> 的每个循环体都有各自不同的 <code>i</code> 变量，所以输出了<code>1,2,3,4,5,6</code></p> <h4 id="_2-2-3-闭包实现缓存"><a href="#_2-2-3-闭包实现缓存" class="header-anchor">#</a> 2.2.3 闭包实现缓存</h4> <p>下面的函数实现了，输入的<code>值+1</code>的效果，使用了闭包，可以减少运算次数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">memorize</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span> <span class="token comment">// argumnets是伪数组，经过slice处理之后，成为了真数组</span>
    <span class="token keyword">let</span> key <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span> <span class="token comment">// 把参数作为cache对象的键，首先将其转换成字符串</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">cache</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">return</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>fn<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token comment">// 如果与之前计算的参数相同，则返回值。否则将计算结果赋值给cache对象的一个键，apply的第二个参数是个数组</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">// 计算的回调函数</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">add参数a</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> adder <span class="token operator">=</span> <span class="token function">memorize</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span>

<span class="token function">adder</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 打印 cache: undefined, console.log: 2, 当前 cache: {'[1]'}</span>
<span class="token function">adder</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment">// 打印 cache: 2  console.log: 2  当前: cache: { '[1]': 2 }</span>
<span class="token function">adder</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 打印 cache: undefined      console.log: 3  当前: cache: { '[1]': 2, '[2]': 3 }</span>
</code></pre></div><p>ES6 的写法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">memorize</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token comment">// args变成了可迭代对象，数组</span>
    <span class="token keyword">const</span> key <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">stringify</span><span class="token punctuation">(</span>args<span class="token punctuation">)</span>
    <span class="token keyword">return</span> cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">||</span> <span class="token punctuation">(</span>cache<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter">a</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">add参数a</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">,</span> a<span class="token punctuation">)</span>
  <span class="token keyword">return</span> a <span class="token operator">+</span> <span class="token number">1</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> adder <span class="token operator">=</span> <span class="token function">memorize</span><span class="token punctuation">(</span>add<span class="token punctuation">)</span>

<span class="token function">adder</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">adder</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token function">adder</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
</code></pre></div><p>闭包可以用来保存变量，缓存变量，但是过多的闭包会使得内存无法及时得到释放</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li><a href="">你不知道的 javascript 上闭包和作用域</a></li> <li><a href="">JS 高级程序设计第四章</a></li> <li><a href="">JS 高级程序设计第七章</a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">LastEditTime:</span> <span class="time">2020-4-24 4:20:01 ├F10: PM┤</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/js-base/call.html" class="prev">
        call, apply, bind手动实现
      </a></span> <span class="next"><a href="/js-base/copy.html">
        赋值与深浅拷贝
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><div id="live2d-widget" class="live2d-widget-container" style="position:fixed;right:30px;bottom:30px;width:135px;height:300px;z-index:99999;opacity:0.8;pointer-events:none;"><canvas id="live2d_canvas" width="135" height="300" class="live2d_canvas" style="position:absolute;left:0px;top:0px;width:135px;height:300px;"></canvas></div></div></div>
    <script src="/assets/js/app.2bd044f4.js" defer></script><script src="/assets/js/2.f4862a58.js" defer></script><script src="/assets/js/41.7a986dc7.js" defer></script>
  </body>
</html>
