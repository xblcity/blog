(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{615:function(a,t,e){"use strict";e.r(t);var r=e(48),_=Object(r.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"从输入网址到页面渲染经历了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#从输入网址到页面渲染经历了什么"}},[a._v("#")]),a._v(" 从输入网址到页面渲染经历了什么")]),a._v(" "),e("p",[a._v("从用户在地址栏输入网址开始到页面渲染完毕，主要由两部分组成。")]),a._v(" "),e("ol",[e("li",[a._v("网络层面")]),a._v(" "),e("li",[a._v("浏览器渲染层面")])]),a._v(" "),e("p",[a._v("大致可以分成以下步骤：")]),a._v(" "),e("ol",[e("li",[a._v("输入网址，回车")]),a._v(" "),e("li",[a._v("缓存解析：如果浏览器本地缓存有资源从缓存取资源")]),a._v(" "),e("li",[a._v("域名解析：DNS 解析，将域名解析成 IP，如果缓存中存在，直接丛缓存中取 IP，不用做域名解析")]),a._v(" "),e("li",[a._v("发送请求：向服务器发送请求")]),a._v(" "),e("li",[a._v("TCP 连接、三次握手：建立浏览器端和服务器端连接")]),a._v(" "),e("li",[a._v("服务器接到请求：服务器响应请求")]),a._v(" "),e("li",[a._v("数据传输")]),a._v(" "),e("li",[a._v("浏览器端拿到数据，解析 html 文件，构建 DOM 树，CSSOM 树，js 文件的加载可能会阻塞页面的渲染")]),a._v(" "),e("li",[a._v("初始的 html 被完全加载和解析后会触发 DOMContentLoaded 事件")]),a._v(" "),e("li",[a._v("CSSOM 树和 DOM 树构建完成后会开始生成 Render 树，绘制")]),a._v(" "),e("li",[a._v("在生成 Render 树的过程中，浏览器就开始调用 GPU 绘制，合成图层，将内容显示在屏幕上")]),a._v(" "),e("li",[a._v("没有文件传输，四次挥手，TCP 连接断开")])]),a._v(" "),e("p",[a._v("对这些步骤进行分析，并对其进行优化")]),a._v(" "),e("h2",{attrs:{id:"_2-缓存解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-缓存解析"}},[a._v("#")]),a._v(" 2.缓存解析")]),a._v(" "),e("h3",{attrs:{id:"_2-1-缓存优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-缓存优先级"}},[a._v("#")]),a._v(" 2.1 缓存优先级")]),a._v(" "),e("ol",[e("li",[a._v("Service Worker")]),a._v(" "),e("li",[a._v("Memory Cache")]),a._v(" "),e("li",[a._v("Disk Cache")]),a._v(" "),e("li",[a._v("Push Cache")]),a._v(" "),e("li",[a._v("网络请求")])]),a._v(" "),e("h4",{attrs:{id:"memory-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#memory-cache"}},[a._v("#")]),a._v(" Memory Cache")]),a._v(" "),e("p",[a._v("Memory Cache，内存中的缓存，读取内存中的数据肯定比磁盘快。但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。 一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。")]),a._v(" "),e("h4",{attrs:{id:"disk-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#disk-cache"}},[a._v("#")]),a._v(" Disk Cache")]),a._v(" "),e("p",[a._v("Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache 胜在容量和存储时效性上。")]),a._v(" "),e("p",[a._v("在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。")]),a._v(" "),e("h4",{attrs:{id:"push-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#push-cache"}},[a._v("#")]),a._v(" Push Cache")]),a._v(" "),e("p",[a._v("Push Cache 是 HTTP/2 中的内容，当以上三种缓存都没有命中时，它才会被使用。并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。")]),a._v(" "),e("h4",{attrs:{id:"网络请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#网络请求"}},[a._v("#")]),a._v(" 网络请求")]),a._v(" "),e("p",[a._v("如果所有缓存都没有命中的话，那么只能发起请求来获取资源了。")]),a._v(" "),e("h3",{attrs:{id:"_2-2-缓存策略-机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-缓存策略-机制"}},[a._v("#")]),a._v(" 2.2 缓存策略/机制")]),a._v(" "),e("h4",{attrs:{id:"强缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#强缓存"}},[a._v("#")]),a._v(" 强缓存")]),a._v(" "),e("p",[a._v("强缓存若命中则直接从缓存中获取资源，不会再与服务端发生通信。")]),a._v(" "),e("p",[a._v("强缓存可以通过设置两种 HTTP Header 实现：Expires 和 Cache-Control 。强缓存表示在缓存期间不需要请求，state code 为 200。")]),a._v(" "),e("h5",{attrs:{id:"expires"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#expires"}},[a._v("#")]),a._v(" Expires")]),a._v(" "),e("p",[a._v("Expires 是一个时间戳，即缓存过期时间，但受限于本地时间")]),a._v(" "),e("h5",{attrs:{id:"cache-control"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#cache-control"}},[a._v("#")]),a._v(" Cache-Control")]),a._v(" "),e("p",[a._v("Cache-Control 可以视作是 expires 的完全替代方案。在当下的前端实践里，我们继续使用 expires 的唯一目的就是向下兼容。")]),a._v(" "),e("h6",{attrs:{id:"max-age"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#max-age"}},[a._v("#")]),a._v(" max-age")]),a._v(" "),e("p",[a._v("Cache-Control 不仅可以设置缓存过期时间")]),a._v(" "),e("h6",{attrs:{id:"public-与-private"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#public-与-private"}},[a._v("#")]),a._v(" public 与 private")]),a._v(" "),e("p",[a._v("public 与 private 可以设置资源是否能够被代理服务缓存。")]),a._v(" "),e("h6",{attrs:{id:"no-store-no-cache"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#no-store-no-cache"}},[a._v("#")]),a._v(" no-store/no-cache")]),a._v(" "),e("p",[a._v("no-cache 绕开了浏览器：我们为资源设置了 no-cache 后，每一次发起请求都不会再去询问浏览器的缓存情况，而是直接向服务端去确认该资源是否过期（即协商缓存）")]),a._v(" "),e("p",[a._v("no-store 比较绝情，顾名思义就是不使用任何缓存策略。在 no-cache 的基础上，它连服务端的缓存确认也绕开了，只允许你直接向服务端发送请求、并下载完整的响应。")]),a._v(" "),e("h4",{attrs:{id:"协商缓存"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#协商缓存"}},[a._v("#")]),a._v(" 协商缓存")]),a._v(" "),e("p",[a._v("协商缓存依赖于服务端与浏览器之间的通信。")]),a._v(" "),e("p",[a._v("协商缓存机制下，浏览器需要向服务器去询问缓存的相关信息，进而判断是重新发起请求、下载完整的响应，还是从本地获取缓存的资源。")]),a._v(" "),e("p",[a._v("如果服务端提示缓存资源未改动（Not Modified），资源会被重定向到浏览器缓存，这种情况下网络请求对应的状态码是 304")]),a._v(" "),e("h5",{attrs:{id:"last-modified"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#last-modified"}},[a._v("#")]),a._v(" Last-Modified")]),a._v(" "),e("p",[a._v("Last-Modified 是一个时间戳，如果我们启用了协商缓存，它会在首次请求时随着 Response Headers 返回 "),e("code",[a._v("Last-Modified: Fri, 27 Oct 2017 06:35:57 GMT")])]),a._v(" "),e("p",[a._v("随后我们每次请求时，会带上一个叫 If-Modified-Since 的时间戳字段，它的值正是上一次 response 返回给它的 last-modified 值："),e("code",[a._v("If-Modified-Since: Fri, 27 Oct 2017 06:35:57 GMT")])]),a._v(" "),e("p",[a._v("服务器接收到这个时间戳后，会比对该时间戳和资源在服务器上的最后修改时间是否一致，从而判断资源是否发生了变化。如果发生了变化，就会返回一个完整的响应内容，并在 Response Headers 中添加新的 Last-Modified 值；否则，返回如上图的 304 响应，Response Headers 不会再添加 Last-Modified 字段。")]),a._v(" "),e("p",[a._v("Last-Modified 存在一些弊端: 我们编辑了文件，但文件的内容没有改变。If-Modified-Since 只能检查到以秒为最小计量单位的时间差,当我们修改文件的速度过快时,感知不到文件的改动")]),a._v(" "),e("h5",{attrs:{id:"etag"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#etag"}},[a._v("#")]),a._v(" Etag")]),a._v(" "),e("p",[a._v("Etag 是由服务器为每个资源生成的唯一的标识字符串，这个标识字符串是基于文件内容编码的，只要文件内容不同，它们对应的 Etag 就是不同的，反之亦然。因此 Etag 能够精准地感知文件的变化。")]),a._v(" "),e("p",[a._v("Etag 和 Last-Modified 类似，当首次请求时，我们会在响应头里获取到一个最初的标识符字符串，它可以是这样的 "),e("code",[a._v('ETag: W/"2a3b-1602480f459"')])]),a._v(" "),e("p",[a._v("那么下一次请求时，请求头里就会带上一个值相同的、名为 if-None-Match 的字符串供服务端比对了："),e("code",[a._v('If-None-Match: W/"2a3b-1602480f459"')])]),a._v(" "),e("p",[a._v("Etag 的生成过程需要服务器额外付出开销，会影响服务端的性能，这是它的弊端。Etag 并不能替代 Last-Modified，它只能作为 Last-Modified 的补充和强化存在。 Etag 在感知文件变化上比 Last-Modified 更加准确，优先级也更高。当 Etag 和 Last-Modified 同时存在时，以 Etag 为准。")]),a._v(" "),e("h2",{attrs:{id:"_3-域名解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_3-域名解析"}},[a._v("#")]),a._v(" 3.域名解析")]),a._v(" "),e("p",[a._v("DNS 解析也是需要时间的，可以通过预解析的方式来预先获得域名所对应的 IP。")]),a._v(" "),e("p",[a._v("比如 quicklink，prefetch，preload")]),a._v(" "),e("h2",{attrs:{id:"_4-发送请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_4-发送请求"}},[a._v("#")]),a._v(" 4.发送请求")]),a._v(" "),e("p",[a._v("多个请求一起发出去，"),e("code",[a._v("Promise.all()")])]),a._v(" "),e("p",[a._v("使用防抖节流限制发送请求的次数")]),a._v(" "),e("p",[a._v("减少 cookie 或者不用")]),a._v(" "),e("p",[a._v("使用 cdn 能够更快拿到响应内容，可以把静态资源放在上面，cdn 域名不一样，也可以减少 cookie 的传输。")]),a._v(" "),e("h2",{attrs:{id:"_5-tcp-连接、三次握手-建立浏览器端和服务器端连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_5-tcp-连接、三次握手-建立浏览器端和服务器端连接"}},[a._v("#")]),a._v(" 5.TCP 连接、三次握手：建立浏览器端和服务器端连接")]),a._v(" "),e("h2",{attrs:{id:"_6-服务器接到请求-服务器响应请求"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_6-服务器接到请求-服务器响应请求"}},[a._v("#")]),a._v(" 6.服务器接到请求：服务器响应请求")]),a._v(" "),e("h2",{attrs:{id:"_7-数据传输"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_7-数据传输"}},[a._v("#")]),a._v(" 7.数据传输")]),a._v(" "),e("p",[a._v("减少图片的大小")]),a._v(" "),e("p",[a._v("雪碧图")]),a._v(" "),e("h2",{attrs:{id:"_8-浏览器端拿到数据"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_8-浏览器端拿到数据"}},[a._v("#")]),a._v(" 8.浏览器端拿到数据")]),a._v(" "),e("p",[a._v("懒加载")]),a._v(" "),e("h2",{attrs:{id:"_9-html解析"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_9-html解析"}},[a._v("#")]),a._v(" 9.html解析")]),a._v(" "),e("h2",{attrs:{id:"_10-render树"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_10-render树"}},[a._v("#")]),a._v(" 10.render树")]),a._v(" "),e("h2",{attrs:{id:"_11-gpu绘制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_11-gpu绘制"}},[a._v("#")]),a._v(" 11.GPU绘制")]),a._v(" "),e("h2",{attrs:{id:"_12-tcp断开连接"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_12-tcp断开连接"}},[a._v("#")]),a._v(" 12.TCP断开连接")]),a._v(" "),e("h2",{attrs:{id:"参考"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#参考"}},[a._v("#")]),a._v(" 参考")]),a._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://github.com/skyline75489/what-happens-when-zh_CN",target:"_blank",rel:"noopener noreferrer"}},[a._v("当···时发生了什么？"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/post/5d66655a5188256c3920b35d",target:"_blank",rel:"noopener noreferrer"}},[a._v("应用：前端性能监控 performance"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/book/5b936540f265da0a9624b04b/section/5b936540f265da0aec223b5d",target:"_blank",rel:"noopener noreferrer"}},[a._v("掘金小册-前端性能优化原理与实践"),e("OutboundLink")],1)]),a._v(" "),e("li",[e("a",{attrs:{href:"https://juejin.im/book/5b936540f265da0a9624b04b/section/5b936540f265da0aec223b5d",target:"_blank",rel:"noopener noreferrer"}},[a._v("掘金小册-前端面试之道"),e("OutboundLink")],1)])])])}),[],!1,null,null,null);t.default=_.exports}}]);